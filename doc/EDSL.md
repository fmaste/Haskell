# [Formal Language](https://en.wikipedia.org/wiki/Formal_language)

In logic, mathematics, computer science, and linguistics, a formal language consists of ***words whose letters are taken from an alphabet*** and are ***well-formed according to a specific set of rules***.

In formal languages words (as in string like ```if a > 0 then True else False```) is a finite sequence of [symbols, letters, or tokens](https://en.wikipedia.org/wiki/Symbol_(formal)) (as in ```if```, ```then```, ```else```, ```>```, ```a```) that are chosen from a set called an [alphabet](https://en.wikipedia.org/wiki/Alphabet_(computer_science)).

The words that belong to a particular formal language, that adhere to the rules specified on the formal language specification, are called well-formed words or well-formed formulas.

There are many languages that can be described by rules, such as [regular languages](https://en.wikipedia.org/wiki/Regular_language) or [context-free languages](https://en.wikipedia.org/wiki/Context-free_language). This two provide a good compromise between expressiveness and ease of parsing, and are widely used in practical applications.

## Grammar

Formal languages are used as tools in multiple disciplines. However, formal language theory rarely concerns itself with particular languages (except as examples), but is mainly concerned with the study of various types of formalisms to describe languages. For instance, a language can be given as:
- Those strings generated by some formal grammar
- Those strings described or matched by a particular regular expression;
- Those strings accepted by some automaton, such as a Turing machine or finite-state automaton;
- Those strings for which some decision procedure (an algorithm that asks a sequence of related YES/NO questions) produces the answer YES.

 In computer science a formal language is often defined by means of a [formal grammar](https://en.wikipedia.org/wiki/Formal_grammar) such as a [regular grammar](https://en.wikipedia.org/wiki/Regular_grammar) or [context-free grammar](https://en.wikipedia.org/wiki/Context-free_grammar), which consists of its formation rules.

Regular grammar is a subset of context free grammar, but not every context free grammar is a regular grammar.

## Abstract Syntax Tree

Programming languages compilers usually have a two stage [parser](https://en.wikipedia.org/wiki/Parser):
- [Lexical analysis](https://en.wikipedia.org/wiki/Lexical_analysis): the input character stream is split into meaningful symbols defined by a grammar of [regular expressions](https://en.wikipedia.org/wiki/Regular_expression).
- Syntactic analysis: which is checking that the tokens form an allowable expression.

The final phase is semantic parsing or analysis. This usually done with an [abstract syntax tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree) that is used by subsequent stages of the compiler to eventually generate an executable containing machine code that runs directly on the hardware, or some intermediate code that requires a virtual machine to execute.

# EDSL

Haskell's mathematical notation and rich and versatile type system makes it a good playground for domain specific languages or EDSL for short.

For example a structure like the one below allows us to build a formal language specification, grammar parser and abstract syntax tree all at once.

```
data LogicExpr =
        Var Int |
        Not LogicExpr |
        And LogicExpr LogicExpr |
        Or LogicExpr LogicExpr

eval :: (Int -> Bool) -> LogicExpr -> Bool
...

>> eval (>= 1) ( Or (Not $ Var 1 ) ( And (Var 2) (Var 3) ) )
True
```
